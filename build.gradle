plugins {
    id 'architectury-plugin' version "${architect_plugin_version}" apply false
    id 'dev.architectury.loom' version "${architectury_loom_version}" apply false
    id 'com.github.johnrengelman.shadow' version "${shadow_plugin_version}" apply false
    id 'org.ajoberstar.grgit' version "${grgit_plugin_version}"
    id 'me.shedaniel.unified-publishing' version "${unified_publishing_plugin_version}" apply false
}

apply from: 'gradle/scripts/helper.gradle'

def ENV = System.getenv()

logger.lifecycle("Syncing SinoSeries. Build version: ${helpers.getBuildVersion(rootProject)}")

allprojects {
    apply plugin: 'maven-publish'
    apply plugin: 'architectury-plugin'
    apply plugin: 'dev.architectury.loom'
    apply plugin: 'me.shedaniel.unified-publishing'

    group = 'games.moegirl.sinocraft'

    architectury {
        minecraft = rootProject.minecraft_version
    }

    loom {
        silentMojangMappingsLicense()
        setEnableTransitiveAccessWideners true
        setEnableModProvidedJavadoc true
    }

    repositories {
        maven {
            name = 'ParchmentMC'
            url = 'https://maven.parchmentmc.org'
        }

        maven {
            name = 'NeoForge'
            url = 'https://maven.neoforged.net/releases/'
        }

        maven {
            name = 'Shedaniel'
            url = 'https://maven.shedaniel.me'
        }

        maven {
            name = 'Yuluo'
            url = 'https://maven.yuluo.dev/repository/maven-public/'
        }

        exclusiveContent {
            forRepository {
                maven {
                    name = "Modrinth"
                    url = "https://api.modrinth.com/maven"
                }
            }

            filter {
                includeGroup "maven.modrinth"
            }
        }
    }

    dependencies {
        minecraft "com.mojang:minecraft:${rootProject.minecraft_version}"

        mappings loom.layered() {
            officialMojangMappings()
            parchment("org.parchmentmc.data:parchment-${rootProject.parchment_minecraft_version}:${rootProject.parchment_version}@zip")
        }
    }

    java {
        withSourcesJar()

        sourceCompatibility = JavaVersion.VERSION_21
        targetCompatibility = JavaVersion.VERSION_21
    }

    tasks.withType(JavaCompile).configureEach {
        it.options.release = 21
    }

    sourcesJar {
        duplicatesStrategy = DuplicatesStrategy.EXCLUDE
    }

    sourceSets.main.resources {
        srcDir 'src/main/resources'
        srcDir 'src/generated/resources'
    }

    processResources {
        duplicatesStrategy = DuplicatesStrategy.EXCLUDE
        exclude('mod_desc.txt')
    }

    tasks.withType(JavaCompile).configureEach {
        options.encoding = "UTF-8"
        options.release = 21
    }

    publishing {
        repositories {
            mavenLocal()

            maven {
                name = 'YuluoMaven'

                def releaseUrl = 'https://maven.yuluo.dev/repository/maven-releases/'
                def snapshotUrl = 'https://maven.yuluo.dev/repository/maven-snapshots/'
                url = ENV.SINOSERIES_RELEASE ? releaseUrl : snapshotUrl

                credentials {
                    username System.getenv('SINOSERIES_MAVEN_USER')
                    password System.getenv('SINOSERIES_MAVEN_PASS')
                }
            }
        }
    }

    tasks.publishUnified.doFirst {
        if (!ENV.SINOSERIES_RELEASE) {
            println 'Hint: Not running in release mode, do NOT use publishUnified.'
        }
    }
}

subMod.each { Project mod ->
    Map<String, ?> propertiesToExpend = helpers.getPropertiesToExpand(mod)
    Map<String, ?> propertiesToExpendFabric = helpers.getPropertiesToExpand(mod, true)
    List<String> filesToMatch = helpers.getFilesToMatchExpand()

    configure(mod) {
        architectury {
            common(((String) rootProject.mod_platforms).split(','))
        }

        version = helpers.getVersion(project)

        loom {
            var aw = mod.file("src/main/resources/${mod.modid}.accesswidener")
            if (aw.exists()) {
                accessWidenerPath = aw
            }

            interfaceInjection {
                enableDependencyInterfaceInjection = true
            }

            runConfigs.configureEach { config ->
                ideConfigGenerated = false
            }
        }

        dependencies {
            // qyl27: Use fabric-loader in order to use EnvType class.
            modImplementation "net.fabricmc:fabric-loader:${mod.fabric_loader_version}"

            if (!mod.name.startsWith('sinocore')) {
                api project(path: ':sinocore', configuration: 'namedElements')
            }

            compileOnly group: 'org.spongepowered', name: 'mixin', version: '0.8.5'
        }

        processResources {
            filesMatching(filesToMatch, (copy) -> {
                expand(propertiesToExpend)
            })
        }
    }

    configure(mod.subprojects) { Project sub ->
        apply plugin: 'com.github.johnrengelman.shadow'

        version = mod.version

        loom {
            accessWidenerPath = mod.loom.accessWidenerPath

            interfaceInjection {
                enableDependencyInterfaceInjection = true
            }

            runConfigs.configureEach { config ->
                ideConfigGenerated = false
            }
        }

        configurations {
            common {
                canBeResolved = true
                canBeConsumed = false
            }

            compileClasspath.extendsFrom common
            runtimeClasspath.extendsFrom common

            shadowBundle {
                canBeResolved = true
                canBeConsumed = false
            }
        }

        shadowJar {
            exclude 'architectury.common.json'

            configurations = [project.configurations.shadowBundle]
            archiveClassifier = 'dev-shadow'
        }

        remapJar {
            injectAccessWidener = true
            input.set shadowJar.archiveFile
            dependsOn shadowJar
        }

        sourcesJar {
            var commonSources = mod.sourcesJar
            dependsOn commonSources
            from commonSources.archiveFile.map { zipTree(it) }
        }

        components.java {
            withVariantsFromConfiguration(sub.configurations.shadowRuntimeElements) {
                skip()
            }
        }

        dependencies {
            if (!mod.name.startsWith('sinocore')) {
                api project(path: ':sinocore', configuration: 'namedElements')
            }
        }

        publishing {
            publications {
                mavenJava(MavenPublication) {
                    from components.java
                }
            }
        }
    }

    configure(helpers.getSubNeoForgeMod(mod)) { Project neoForgeMod ->
        architectury {
            platformSetupLoomIde()
            neoForge()
        }

        loom {
            runConfigs.configureEach { config ->
                ideConfigGenerated = false
            }
        }

        sourceSets.main.resources {
            srcDir(new File(mod.projectDir, 'src/main/resources'))
            srcDir(new File(mod.projectDir, 'src/generated/resources'))
        }

        dependencies {
            neoForge "net.neoforged:neoforge:${neoForgeMod.neoforge_version}"

            common(project(path: mod.path, configuration: 'namedElements')) { transitive = false }
            shadowBundle project(path: mod.path, configuration: 'transformProductionNeoForge')
        }

        processResources {
            filesMatching(filesToMatch, (copy) -> {
                expand(propertiesToExpend)
            })
        }

        remapJar {
            if (mod.loom.accessWidenerPath.present) {
                atAccessWideners.add(mod.loom.accessWidenerPath.get().asFile.name)
            }
        }
    }

    configure(helpers.getSubFabricMod(mod)) { Project fabricMod ->
        architectury {
            platformSetupLoomIde()
            fabric()
        }

        loom {
            runConfigs.configureEach { config ->
                ideConfigGenerated = false
            }
        }

        dependencies {
            modImplementation "net.fabricmc:fabric-loader:${fabricMod.fabric_loader_version}"
            modApi "net.fabricmc.fabric-api:fabric-api:${fabricMod.fabric_api_version}"

            common(project(path: mod.path, configuration: 'namedElements')) { transitive = false }
            shadowBundle project(path: mod.path, configuration: 'transformProductionFabric')
        }

        processResources {
            filesMatching(filesToMatch, (copy) -> {
                expand(propertiesToExpendFabric)
            })
        }
    }
}

loom {
    runConfigs.configureEach { config ->
        ideConfigGenerated = false
    }
}

helpers.reGenRunConfig()
