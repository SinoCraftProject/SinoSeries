plugins {
    id 'architectury-plugin' version "${architect_plugin_version}" apply false
    id 'dev.architectury.loom' version "${architectury_loom_version}" apply false
    id 'com.gradleup.shadow' version "${shadow_plugin_version}" apply false
    id 'me.shedaniel.unified-publishing' version "${unified_publishing_plugin_version}" apply false
}

apply from: 'gradle/scripts/base.gradle'

logger.lifecycle("Syncing SinoSeries. Build version: ${ext.getBuildVersion(rootProject)}")

// <editor-fold desc="Common">

def ENV = System.getenv()

allprojects {
    repositories {
        maven {
            name = 'ParchmentMC'
            url = 'https://maven.parchmentmc.org'
        }

        maven {
            name = 'NeoForge'
            url = 'https://maven.neoforged.net/releases/'
        }

        maven {
            name = 'Shedaniel'
            url = 'https://maven.shedaniel.me'
        }

        maven {
            name = 'Yuluo'
            url = 'https://maven.yuluo.dev/repository/maven-public/'
        }

        exclusiveContent {
            forRepository {
                maven {
                    name = "Modrinth"
                    url = "https://api.modrinth.com/maven"
                }
            }

            filter {
                includeGroup "maven.modrinth"
            }
        }
    }
}

subprojects {
    apply plugin: 'java'
    apply plugin: 'maven-publish'
    apply plugin: 'architectury-plugin'
    apply plugin: 'dev.architectury.loom'
    apply plugin: 'me.shedaniel.unified-publishing'

    group = 'games.moegirl.sinocraft'

    architectury {
        minecraft = rootProject.minecraft_version
    }

    loom {
        silentMojangMappingsLicense()
        setEnableTransitiveAccessWideners true
        setEnableModProvidedJavadoc true

        interfaceInjection {
            enableDependencyInterfaceInjection = true
        }
    }

    dependencies {
        minecraft "com.mojang:minecraft:${rootProject.minecraft_version}"

        mappings loom.layered() {
            officialMojangMappings()
            parchment("org.parchmentmc.data:parchment-${rootProject.parchment_minecraft_version}:${rootProject.parchment_version}@zip")
        }
    }

    java {
        withSourcesJar()

        sourceCompatibility = JavaVersion.VERSION_21
        targetCompatibility = JavaVersion.VERSION_21
    }

    tasks.withType(JavaCompile).configureEach {
        it.options.release = 21
    }

    sourcesJar {
        duplicatesStrategy = DuplicatesStrategy.EXCLUDE
    }

    processResources {
        duplicatesStrategy = DuplicatesStrategy.EXCLUDE
        exclude('mod_desc.txt')
    }

    tasks.withType(JavaCompile).configureEach {
        options.encoding = 'UTF-8'
        options.release = 21
    }

    publishing {
        repositories {
            mavenLocal()

            maven {
                name = 'YuluoMaven'

                def releaseUrl = 'https://maven.yuluo.dev/repository/maven-releases/'
                def snapshotUrl = 'https://maven.yuluo.dev/repository/maven-snapshots/'
                url = ENV.MOD_RELEASE ? releaseUrl : snapshotUrl

                credentials {
                    username Objects.requireNonNullElse(System.getenv('MOD_MAVEN_USER'), '')
                    password Objects.requireNonNullElse(System.getenv('MOD_MAVEN_PASS'), '')
                }
            }
        }
    }

    tasks.publishUnified.doFirst {
        if (!ENV.MOD_RELEASE) {
            println 'Hint: Not running in release mode, do NOT use publishUnified.'
        }
    }
}

ext.subModProjects.each { Project p ->
    configure(p) {
        loom {
            runConfigs.configureEach { config ->
                ideConfigGenerated = false
            }
        }

        publishing {
            publications {
                mavenJava(MavenPublication) {
                    version = rootProject.ext.getBuildVersion(p)
                    from components.java
                }
            }
        }
    }
}

ext.commonModProjects.each { Project p ->
    configure(p) {
        architectury {
            common(rootProject.ext.modPlatforms)
        }

        version = rootProject.ext.getVersion(p)

        if (project.hasProperty('mod_version')) {
            rootProject.logger.lifecycle("Project ${p.name} will use self-version string: ${version}")
        }

        loom {
            var aw = p.file("src/main/resources/${p.modid}.accesswidener")
            if (aw.exists()) {
                accessWidenerPath = aw
            }
        }

        sourceSets.main.resources {
            srcDir 'src/main/resources'
            srcDir 'src/generated/resources'
        }

        dependencies {
            // qyl27: Use fabric-loader in order to use EnvType class.
            modImplementation "net.fabricmc:fabric-loader:${rootProject.fabric_loader_version}"

            if (p.name != 'sinocore') {
                api project(path: ':sinocore', configuration: 'namedElements')
            }

            compileOnly group: 'org.spongepowered', name: 'mixin', version: '0.8.5'
        }
    }
}

// </editor-fold>

// <editor-fold desc="Platform">

ext.platformProjects.each { Project p ->
    configure(p) {
        apply plugin: 'com.gradleup.shadow'

        version = p.parent.version

        loom {
            accessWidenerPath = p.parent.loom.accessWidenerPath
        }

        configurations {
            common {
                canBeResolved = true
                canBeConsumed = false
            }

            compileClasspath.extendsFrom common
            runtimeClasspath.extendsFrom common

            shadowBundle {
                canBeResolved = true
                canBeConsumed = false
            }
        }

        processResources {
            var props = rootProject.ext.getExpandingProperties(p.parent, project.name.contains('fabric'))
            filesMatching(rootProject.ext.expandingFilesMatch as List<String>, { FileCopyDetails copy ->
                expand(props)
            })
        }

        shadowJar {
            exclude 'architectury.common.json'

            configurations = [project.configurations.shadowBundle]
            archiveClassifier = 'dev-shadow'
        }

        remapJar {
            duplicatesStrategy = DuplicatesStrategy.EXCLUDE

            injectAccessWidener = true
            input.set shadowJar.archiveFile
            dependsOn shadowJar
        }

        sourcesJar {
            var commonSources = p.parent.sourcesJar
            dependsOn commonSources
            from commonSources.archiveFile.map { zipTree(it) }
        }

        components.java {
            withVariantsFromConfiguration(p.configurations.shadowRuntimeElements) {
                skip()
            }
        }

        dependencies {
            if (!p.name.startsWith('sinocore')) {
                api project(path: ':sinocore', configuration: 'namedElements')
            }
        }

        parent.publish.dependsOn(publish)
        parent.publishUnified.dependsOn(publishUnified)
    }
}

ext.platformNeoForge.each { Project p ->
    configure(p) {
        architectury {
            platformSetupLoomIde()
            neoForge()
        }

        loom {
            runConfigs.configureEach { config ->
                ideConfigGenerated = false
            }
        }

        sourceSets.main.resources {
            srcDir p.parent.file('src/main/resources')
            srcDir p.parent.file('src/generated/resources')
        }

        dependencies {
            neoForge "net.neoforged:neoforge:${rootProject.neoforge_version}"

            common(project(path: p.parent.path, configuration: 'namedElements')) { transitive = false }
            shadowBundle project(path: p.parent.path, configuration: 'transformProductionNeoForge')
        }

        remapJar {
            if (p.parent.loom.accessWidenerPath.present) {
                atAccessWideners.add(p.parent.loom.accessWidenerPath.get().asFile.name)
            }
        }
    }
}

ext.platformFabric.each { Project p ->
    configure(p) {
        architectury {
            platformSetupLoomIde()
            fabric()
        }

        loom {
            runConfigs.configureEach { config ->
                ideConfigGenerated = false
            }
        }

        dependencies {
            modImplementation "net.fabricmc:fabric-loader:${rootProject.fabric_loader_version}"
            modApi "net.fabricmc.fabric-api:fabric-api:${rootProject.fabric_api_version}"

            common(project(path: p.parent.path, configuration: 'namedElements')) { transitive = false }
            shadowBundle project(path: p.parent.path, configuration: 'transformProductionFabric')
        }
    }
}

// </editor-fold>

// <editor-fold desc="Meta">

ext.metaProjects.each { Project p ->
    configure(p) {
        version = rootProject.ext.sinoVersion

        configurations {
            common {
                canBeResolved = true
                canBeConsumed = false
            }

            compileClasspath.extendsFrom common
            runtimeClasspath.extendsFrom common
        }

        dependencies {
            rootProject.ext.commonModProjects.each { Project m ->
                common(project(path: m.path, configuration: 'namedElements')) { transitive true }
            }
        }

        processResources {
            var props = rootProject.ext.getExpandingProperties(p.parent, project.name.contains('fabric'))
            filesMatching(rootProject.ext.expandingFilesMatch as List<String>, { FileCopyDetails copy ->
                expand(props)
            })
        }

        publishing {
            publications {
                mavenJava(MavenPublication) {
                    version = rootProject.ext.getBuildVersion(p)
                    from components.java
                }
            }
        }
    }
}

//
//developmentFabric.extendsFrom common

// </editor-fold>

ext.refreshRunConfig()
